using UnityEngine;
using System.Collections.Generic;
using Leap.Unity;
using Leap.Unity.RuntimeGizmos;
using MeshGeneration;

public class PinchStrokeGenerator : MonoBehaviour, IRuntimeGizmoComponent {

  #region PUBLIC FIELDS

  public Color CurrentColor = Color.red;
  [Range(0.002F, 0.02F)]
  public float CurrentThickness = 0.005F;

  [Tooltip("Strokes can be independently generated by each PinchDetector in this array.")]
  public PinchDetector[] _pinchDetectors;

  [Header("Stroke Generation Settings")]
  public float _minSegmentLength = 0.005F;
  public Material _strokeMeshMaterial;

  #endregion

  #region PRIVATE FIELDS

  private bool[] _isDrawingStroke;
  private StrokeMeshGenerator[] _liveStrokeMeshGenerators;
  private GameObject[] _liveStrokeObjects;
  private Vector3[] _lastAddedStrokePointPerIdx;

  private GameObject _finishedStrokeParent = null;

  #endregion

  #region UNITY CALLBACKS

  protected virtual void Start() {
    _isDrawingStroke = new bool[_pinchDetectors.Length];
    _liveStrokeMeshGenerators = new StrokeMeshGenerator[_pinchDetectors.Length];
    _liveStrokeObjects = new GameObject[_pinchDetectors.Length];
    _lastAddedStrokePointPerIdx = new Vector3[_pinchDetectors.Length];

    _finishedStrokeParent = new GameObject();
    _finishedStrokeParent.name = "Strokes";
    _finishedStrokeParent.AddComponent<RuntimeGizmoToggle>().enabled = false;

    for (int i = 0; i < _pinchDetectors.Length; i++) {
      GameObject liveStrokeObj = _liveStrokeObjects[i] = new GameObject();
      liveStrokeObj.name = "Live Stroke Mesh";
      liveStrokeObj.AddComponent<MeshRenderer>().material = _strokeMeshMaterial;
      MeshFilter meshFilter = liveStrokeObj.AddComponent<MeshFilter>();
      _liveStrokeMeshGenerators[i] = new StrokeMeshGenerator().
        SetMode(StrokeMeshMode.Ribbons).
        SetThickness(0.005F).
        SetColor(Color.red);
      _liveStrokeMeshGenerators[i].OnMeshChanged += (x) => { meshFilter.mesh = x; };
    }
  }

  protected virtual void Update() {
    for (int pinchIdx = 0; pinchIdx < _pinchDetectors.Length; pinchIdx++) {

      _liveStrokeMeshGenerators[pinchIdx].Color = this.CurrentColor;
      _liveStrokeMeshGenerators[pinchIdx].Thickness = this.CurrentThickness;

      if (ShouldBeDrawingStroke(pinchIdx) && !_isDrawingStroke[pinchIdx]) {
        BeginStroke(pinchIdx);
        _isDrawingStroke[pinchIdx] = true;
      }
      else if (ShouldBeDrawingStroke(pinchIdx) && _isDrawingStroke[pinchIdx]) {
        UpdateStroke(pinchIdx);
      }
      else if (!ShouldBeDrawingStroke(pinchIdx) && _isDrawingStroke[pinchIdx]) {
        EndStroke(pinchIdx);
        _isDrawingStroke[pinchIdx] = false;
      }
    }
  }

  #endregion

  #region PRIVATE METHODS

  private bool ShouldBeDrawingStroke(int pinchIdx) {
    return _pinchDetectors[pinchIdx].IsPinching;
  }

  private void BeginStroke(int pinchIdx) {
    // TODO HACK FIXME
    this.CurrentColor = _pinchDetectors[pinchIdx].GetComponentInParent<IHandModel>().GetComponentInChildren<IndexTipColor>().GetColor();
    _liveStrokeMeshGenerators[pinchIdx].BeginStrokeMesh();
  }

  private void UpdateStroke(int pinchIdx) {
    Vector3 lastAddedStrokePoint = _lastAddedStrokePointPerIdx[pinchIdx];
    PinchDetector pinchDetector = _pinchDetectors[pinchIdx];

    bool shouldAdd = lastAddedStrokePoint == Vector3.zero
      || Vector3.Distance(lastAddedStrokePoint, pinchDetector.transform.position) >= _minSegmentLength;

    if (shouldAdd) {
      _liveStrokeMeshGenerators[pinchIdx].AddStrokeMeshPoint(pinchDetector.transform.position, pinchDetector.transform.rotation * Quaternion.Euler(new Vector3(90F, 0F, 180F)));
      _lastAddedStrokePointPerIdx[pinchIdx] = pinchDetector.transform.position;
    }
  }

  private void EndStroke(int pinchIdx) {
    GameObject finishedStrokeObj = new GameObject();
    finishedStrokeObj.transform.parent = _finishedStrokeParent.transform;
    finishedStrokeObj.AddComponent<MeshFilter>().mesh = _liveStrokeMeshGenerators[pinchIdx].FinalizeMesh();
    finishedStrokeObj.AddComponent<MeshRenderer>().material = _strokeMeshMaterial;

    _liveStrokeMeshGenerators[pinchIdx].Clear();
  }

  #endregion

  #region GIZMOS

  private bool _drawStrokeGizmos = false;
  private bool _drawStrokeLine = true;
  private bool _drawRibbonNormals = true;
  private bool _drawRibbonBinormals = true;

  public void OnDrawRuntimeGizmos(RuntimeGizmoDrawer drawer) {
    if (!_drawStrokeGizmos) return; // TODO REMOVE, also this function is expecting two registered pinch detectors
    if (_liveStrokeMeshGenerators == null || _liveStrokeMeshGenerators[1] == null) return;
    List<MeshPoint> meshPoints = _liveStrokeMeshGenerators[1].GetSmoothMeshPoints();
    List<bool> flipRegisterStates = _liveStrokeMeshGenerators[1].GetFlipRegisters();

    if (_drawStrokeGizmos) {

      for (int i = 0; i < meshPoints.Count - 1; i++) {

        if (_drawStrokeLine) {
          drawer.color = Color.blue;
          drawer.DrawLine(meshPoints[i].Position, meshPoints[i + 1].Position);
          if (flipRegisterStates[i]) { drawer.color = Color.yellow; }
          drawer.DrawSphere(meshPoints[i].Position, 0.002F);
        }

        if (_drawRibbonNormals) {
          Vector3 normalDirection = meshPoints[i].Normal;

          drawer.color = new Color(1.0F, 0.4F, 0.2F);
          drawer.DrawLine(meshPoints[i].Position, meshPoints[i].Position + normalDirection * 0.01F);
        }

        if (_drawRibbonBinormals) {
          Vector3 binormalDirection = Vector3.Cross(meshPoints[i].Normal, (meshPoints[i + 1].Position - meshPoints[i].Position)).normalized;

          drawer.color = Color.red;
          drawer.DrawLine(meshPoints[i].Position - binormalDirection * 0.02F, meshPoints[i].Position + binormalDirection * 0.02F);
          drawer.DrawSphere(meshPoints[i].Position + binormalDirection * 0.02F, 0.001F);
        }

      }
    }
  }

  #endregion

}
